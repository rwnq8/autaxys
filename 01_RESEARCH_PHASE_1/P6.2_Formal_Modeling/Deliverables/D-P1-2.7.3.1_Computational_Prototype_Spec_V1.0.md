---
id: P6.2_ComputationalPrototype_V1.0
title: "Computational Prototype v1.0: Simulating Emergent Transitivity from Ontological Closure"
project_id: AUTX-A.1-P6.2
product_id: P6.2
status: draft
version: 1.0
author: Rowan Brad Quni (with Autologos Assistance)
summary: "This document specifies the design and implementation of a simple computational prototype to test the hypothesis that relational composition rules (specifically transitivity) emerge as a necessary condition for Ontological Closure. Using Python and NetworkX, the simulation will model the `primordialAct`, the composition of two `AsymmetricLink` patterns, and check for self-referential stability (stable fixed points) to validate that only the transitively closed configuration achieves coherence."
---
**1. Objective**

This project moves from conceptual sketches (`P6.2_ModelSketch_Genesis_V2.0.md`) to a concrete, executable simulation. The primary objective is to test the core hypothesis that **composition rules for definitionally emergent relational types are themselves emergent properties, required by the principle of Intrinsic Coherence (modeled as Ontological Closure).**

Specifically, this prototype will simulate the composition of two `AsymmetricLink` patterns and test if **transitivity** (`A->B` and `B->C` implies `A->C`) is a necessary condition for the stability of the resulting composite pattern.

**2. Technical Specification**

*   **Language:** Python 3.9+
*   **Core Libraries:**
    *   `networkx`: For creating, manipulating, and analyzing directed graphs (`DiGraph`), which will represent our autaxic patterns.
    *   `matplotlib`: For visualizing the graph structures.
*   **Environment:** A standard Python environment (e.g., Jupyter Notebook, a standalone script) capable of running these libraries.

**3. Data Structures and Core Concepts**

*   **Pattern Representation:** An autaxic pattern `P` will be represented by a `networkx.DiGraph` object.
    *   **Distinctions (`d`)**: Represented as nodes in the graph (e.g., integers `1`, `2`, `3`).
    *   **AsymmetricLink Relation (`r(source, target)`)**: Represented as a directed edge from the `source` node to the `target` node.
*   **Ontological Closure Check (`CheckCoherence`):** This will be a function that takes a graph `G` as input and determines if it is coherent. In this prototype, coherence is defined as having a **stable fixed point** under a self-application transformation `f(G)`.
    *   `is_coherent(G)` will return `True` if `f(G)` is structurally identical to `G`, and `False` otherwise.

**4. The `f(G)` Self-Application Transformation (v1.0)**

The `f(G)` transformation represents one "tick" of the pattern's intrinsic dynamics. For this prototype, we define a simple rule that tests the local and global consistency of causal flows.

*   **Rule:** For every node `X` in the graph `G`, if there is an incoming path of length 2 (e.g., `A -> B -> X`), the self-application function `f(G)` generates a new graph `G'` which includes all of `G`'s original edges PLUS a "shortcut" edge from the start of that path to `X` (i.e., `A -> X`).
*   **Fixed Point:** A graph `G` is a stable fixed point if it already contains all the "shortcut" edges implied by its existing paths of length 2. In this case, `f(G)` produces no new edges, and thus `G'` is identical to `G`. This means the graph is **transitively closed**.

**5. Simulation Algorithm & Key Functions**

**5.1. `generate_minimal_patterns()`**
This function will implement the `Distinguish` operator from the v2.0 sketch. It will generate two minimal graphs:
1.  `G_undir`: A graph with two nodes and a symmetric connection (modeled as two opposing directed edges for this prototype).
2.  `G_dir`: A graph with two nodes and a single directed edge (`d1 -> d2`).
*   **Returns:** A list `[G_undir, G_dir]`.

**5.2. `is_coherent(G)`**
This function implements the ontological closure check.
1.  Takes a graph `G` as input.
2.  Calculates `G_prime = f(G)` by finding all paths of length 2 and adding the corresponding shortcut edges.
3.  Compares `G` and `G_prime` using `networkx.is_isomorphic(G, G_prime)` (or a simpler edge-set comparison).
4.  Returns `True` if they are identical (it's a fixed point), `False` otherwise.

**5.3. `primordial_act()`**
This function simulates the first generative event.
1.  Calls `generate_minimal_patterns()`.
2.  Iterates through the generated patterns, calling `is_coherent()` on each.
3.  Returns the *first* graph that returns `True`.
4.  **Expected Outcome:** It should find that `G_undir` is unstable (since `f(G_undir)` would add edges, making it different) and that `G_dir` is stable (since it has no paths of length 2, `f(G_dir) = G_dir`). It will return `G_dir`.

**5.4. The Main Experiment: `test_composition()`**
This function will execute the core hypothesis test.
1.  Call `primordial_act()` to get the first stable pattern, `P1 = (1 -> 2)`.
2.  Define a second stable pattern, `P2 = (2 -> 3)`.
3.  **Composition Step:** Create a new graph `G_composite` by combining the nodes and edges of `P1` and `P2`. `G_composite` now represents `{1, 2, 3, r(1,2), r(2,3)}`.
4.  **Coherence Check 1:** Call `is_coherent(G_composite)`.
    *   **Hypothesis:** This will return `False`. The `f(G)` transformation will detect the path `1 -> 2 -> 3` and add the shortcut edge `1 -> 3`, so the resulting graph will not be identical to the input.
5.  **Closure Step:** Manually add the transitive edge `(1, 3)` to `G_composite` to create `G_closed`.
6.  **Coherence Check 2:** Call `is_coherent(G_closed)`.
    *   **Hypothesis:** This will return `True`. Since `G_closed` already contains the edge `(1, 3)`, the `f(G)` transformation will find no new shortcuts to add. The graph is a stable fixed point.
7.  **Conclusion:** The simulation will report whether only the transitively closed graph achieved coherence.

**6. Implementation and Reporting**

*   The Python code will be implemented in a single script or notebook.
*   Functions will be clearly defined and commented to match this specification.
*   The `test_composition()` function will print clear, human-readable output indicating the results of each coherence check and the final conclusion.
*   `matplotlib` will be used to generate and save images of `G_composite` and `G_closed` for visual confirmation.
*   The results will be documented in a new report file, `P6.2_ComputationalPrototype_V1.0_Results.md`, which will analyze the outcome and discuss its implications for the autaxys framework.

**7. Success Criteria**

This prototype will be considered successful if:
1.  The `primordial_act()` function correctly identifies the directed graph as the only stable minimal pattern.
2.  The `test_composition()` function demonstrates that the non-transitively-closed graph is incoherent (unstable).
3.  The `test_composition()` function demonstrates that the transitively-closed graph is coherent (stable).

This outcome would provide the first piece of computational evidence that composition rules can be derived from the fundamental requirement of ontological closure.
